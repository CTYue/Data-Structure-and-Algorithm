//Prim's algorithm by C-Y (Roger) Chen, Syracuse University
//Implemented with min-Heap
//Time Complexity O(N + E log N)

#include <iostream>
#include <vector>
#include <fstream>
using namespace std;
class e_node { //stands for edge node
public:
	int nb;//the neighbor of a currently considered node
	int weight; //weight of the edge to the above neighbor
	e_node() {}//constructor
};

class h_node { //stands for heap_node
public:
	int id;
	int cost;//
	h_node() { id = -1; cost = 9999; }
	h_node(int i, int j) { id = i; cost = j; }
	bool operator<(h_node h) { return (cost < h.cost); }
};

void set_up(vector<h_node> & heap, int &start);
h_node extractMin(vector<h_node> &heap );
void minHeapify(vector<h_node> & heap, int index);
void PrimMst(vector<vector<e_node> > & graph, vector<h_node> &heap);

int main()
{
	ifstream in("text1.txt");
	int start;//
	in >> start;//source node for the Dijkstra's algorithm
	int n, e; //n: num of nodes ; e: num of edges
	in >> n >> e;
	vector<e_node> ve;
	vector<vector<e_node> > graph(n, ve);
	e_node e1;//
	int n1, n2, w;//source, dest and weight
	for (int i = 0; i < e; i++) {
		in >> n1 >> n2 >> w;
		e1.nb = n2;
		e1.weight = w;
		graph[n1].push_back(e1);//add e1 to the tail of graph[n1]
	}
	in.close();
	vector<h_node> heap(n);
	minHeapify(heap,0);
	//Print the shortest path
//	for( int i = 0; i < n; i++)
//		{cout << heap[i].id << " " << heap[i].cost << endl;}

	getchar();
	getchar();
	return 0;
}

void set_up(vector<h_node> & heap, int &start)
{
	for (size_t i = 0; i < heap.size(); i++)
	{
		heap[i].id = i;
	}
	heap[start].id = 0;
	heap[0].id = start;
	heap[0].cost = 0;
}

void minHeapify(vector<h_node> & heap, int index)
{
	int smallest, leftChild, rightChild;
	smallest = index;
	leftChild = 2 * index + 1;
	rightChild = 2* index + 2;

	if( heap.size() > 0  )
	{
		if( leftChild < heap.size() && heap[leftChild].cost < heap[smallest].cost )
			{
				smallest = leftChild;
			}

			if( rightChild < heap.size() && heap[rightChild].cost < heap[smallest].cost )
			{
				smallest = rightChild;
			}

			if( smallest != index)
			{
				//Swap nodes
				int indexId = heap[index].id;
				int indexHeap = heap[index].cost;
				heap[index].id = smallest;
				heap[index].cost = heap[smallest].cost;
				heap[smallest].id = indexId;
				heap[smallest].cost = indexHeap;
				minHeapify(heap, smallest);
			}
	}
}

void PrimMst(vector<vector<e_node> > & graph, vector<h_node> &heap, vector<e_node> &AdjNode)
{
	int v = graph.size();// Get the numbers of vertices in graph
	int parent[v];	 	// Array to store constructed MST
	int key[v]; 			//Key values used to pick minimum weight edge in cut

	key[0] = 0;
	for(int i = 0; i < v; ++i)
	{
		parent[i] = -1;
		key[i] = INT_MAX;
	}

	while( heap.size() != 0 )
	{
		h_node minHeapNode = extractMin(heap);//
		int nodeId = minHeapNode.id;

		//struct AdjListNode* pCrawl = graph->array[u].head;
		 	 	 	 	 	 	 	 //graph[nodeId];
		//vector<e_node> *pCrawl =   ;

		for(int i = 0; i < v; i++)
		{
			//int v = pCrawl->dest;
			//int v = graph[i][i].nb;

//			if( isInMinHeap(minHeap,v) && pCrawl->weight < key[v] )
//			{
//				key[v] = pCrawl->weight;
//				parent[v] = u;
//				decreaseKey(minHeap, v, key[v]);
//			}
//			pCrawl = pCrawl->next;
		 }
	}
}

h_node extractMin(vector<h_node> &heap )
{
	//Store the root node
	int last = heap.size() - 1;
	h_node root;
	root.id = heap[0].id;
	root.cost = heap[0].cost;

	//Replace root node with last node
    heap[0].id = heap[last].id;
    heap[0].cost = heap[last].cost;

    //Reduce heap size and heapify root
    heap.pop_back();
    minHeapify(heap, 0);

    return root;
}
